# event loop


## 请描述 event loop 的机制，可画图


### 什么是事件循环

事件循环是 JavaScript 用来处理异步任务和回调的执行模型

JS 是单线程的，没有多线程，事件循环让他在单线程下也能处理异步操作，而不是阻塞主线程



### 为什么要有这个机制

1. **单线程**：JS只在一个主线程里执行，不能像多线程那样同时跑多段代码

2. **异步需求**：需要发起网络请求，定时期，DOM事件等，如果全部同步执行，会长时间阻塞页面

3. **设计目标**：通过事件循环，把耗时或需要等待的任务交给宿主环境（如浏览器，Node），主线程继续执行当前代码，
等异步完成后再通过回调参与后续执行


- 从前到后，一步一步执行
- 如果某一行执行报错，则停止下面代码的执行
- 先把同步代码执行完，在执行异步（通过回调执行）




### 执行过程

在浏览器中事件循环大致结构如下：

![LOGO](/public/image/base/640-5.gif)

```md

┌───────────────────────────┐
│     Call Stack (调用栈)    │  ← 同步代码在这里执行
└─────────────┬─────────────┘
              │
              ▼
┌──────────────────────────┐
│  执行栈为空？取出一个宏任务  |
└─────────────┬────────────┘
              │
    ┌─────────┴──────────┐
    │  1. 执行宏任务       │
    │  2. 执行所有微任务    │  ← 微任务优先级更高
    │  3. 更新渲染(如需要)  │
    └─────────┬──────────┘
              │
              ▼
       回到步骤 1，循环

```

1. 执行当前同步代码（压入，弹出调用栈）
2. 同步代码执行完，开始一次事件循环
3. 从宏任务队列中取出一个任务执行
4. 执行过程中产生的微任务全部执行完
5. 可选：浏览器进行一次渲染
6. 重复 2-5


```md

执行 1 个宏任务
    ↓
执行过程中如果产生微任务 → 加入微任务队列
    ↓
当前宏任务执行完后 → 依次执行微任务队列里的所有微任务（直到队列为空）
    ↓
可选：渲染
    ↓
从宏任务队列取下一个宏任务，重复上述过程

微任务里可能再产生新的微任务，
这些新微任务会在“当前宏任务后的微任务阶段”一起执行完，不会留到下一轮。

每一轮事件循环 = 1 个宏任务 + 把微任务队列清空，清空完才会去取下一个宏任务。

queueMicrotask(() => {
  console.log('微任务1');
  queueMicrotask(() => console.log('微任务2'));  // 微任务中又产生微任务
});
queueMicrotask(() => console.log('微任务3'));

// 输出：微任务1 → 微任务3 → 微任务2
```


### 宏任务

```js
setTimeout

setInterval

I/O

UI渲染

整体script

```


### 微任务

```js

Promise.then/catch/finally // Promise状态改变之后的回调

queueMicrotask(callback) // 显式把函数加入微任务队列

MutationObserver // DOM变化时的回调

asycn/await  // await 后的代码相当于放进微任务


```




### 示例


:::code-group

```js [执行顺序]

console.log('1');  // 同步

setTimeout(() => {
  console.log('2');  // 宏任务
}, 0);

Promise.resolve().then(() => {
  console.log('3');  // 微任务
});

console.log('4');  // 同步


// 1 -> 4 -> 3 -> 2

先执行同步：1、4。
主线程空闲后，先执行微任务 Promise.then：3。
再执行宏任务 setTimeout：2。

```


```js [await]

async function demo() {
  console.log('A');
  await Promise.resolve();
  console.log('B');
}
demo();
console.log('C');


A → C → B

await 之后的代码相当于放到微任务里执行，所以 C 先于 B 输出。

```
:::



### 动态图


![LOGO](/public/image/base/640-0.gif)

![LOGO](/public/image/base/640-1.gif)

![LOGO](/public/image/base/640-2.gif)

![LOGO](/public/image/base/640-3.gif)


![LOGO](/public/image/base/640-4.gif)


