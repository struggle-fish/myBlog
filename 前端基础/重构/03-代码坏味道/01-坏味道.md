# 代码坏味道

## 神秘命名（Mysterious Name）

整洁代码最重要的一环就是好的名字，所以我们会深思熟虑如何给函数、模块、变量和类命名，使它们能清晰地表明自己的功能和用法。命名是编程中最难的两件事之一[mf-2h]​。正因为如此，改名可能是最常用的重构手法，包括改变函数声明（124）（用于给函数改名）​、变量改名（137）、字段改名（244）等。

> 变量改名（137）

![LOGO](/public/image/refactoring/RenameVariable.png)

好的命名是整洁编程的核心。变量可以很好地解释一段程序在干什么——如果变量名起得好的话。使用范围越广，名字的好坏就越重要。只在一行的lambda表达式中使用的变量，跟踪起来很容易——像这样的变量，我经常只用一个字母命名，因为变量的用途在这个上下文中很清晰。同理，短函数的参数名也常常很简单。不过在JavaScript这样的动态类型语言中，我喜欢把类型信息也放进名字里（于是变量名可能叫`aCustomer`）​。

> 字段改名（244）

![LOGO](/public/image/refactoring/RenameField.png)



## 重复代码（Duplicated Code）

如果你在一个以上的地点看到相同的代码结构，那么可以肯定：<sapn class="marker-text">设法将它们合而为一，程序会变得更好。一旦有重复代码存在，阅读这些重复的代码时你就必须加倍仔细，留意其间细微的差异。如果要修改重复代码，你必须找出所有的副本来修改。</sapn>



## 过长函数（Long Function）


据我们的经验，活得最长、最好的程序，其中的函数都比较短。初次接触到这种代码库的程序员常常会觉得“计算都没有发生”——程序里满是无穷无尽的委托调用。但和这样的程序共处几年之后，你就会明白这些小函数的价值所在。间接性带来的好处——更好的阐释力、更易于分享、更多的选择——都是由小函数来支持的。


<sapn class="marker-text">最终的效果是：你应该更积极地分解函数。我们遵循这样一条原则：每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名。我们可以对一组甚至短短一行代码做这件事。哪怕替换后的函数调用动作比函数自身还长，只要函数名称能够解释其用途，我们也该毫不犹豫地那么做。关键不在于函数的长度，而在于函数“做什么”和“如何做”之间的语义距离。</sapn>


百分之九十九的场合里，要把函数变短，只需使用提炼函数（106）。找到函数中适合集中在一起的部分，将它们提炼出来形成一个新函数。

如果函数内有大量的参数和临时变量，它们会对你的函数提炼形成阻碍。如果你尝试运用提炼函数（106），最终就会把许多参数传递给被提炼出来的新函数，导致可读性几乎没有任何提升。此时，你可以经常运用以查询取代临时变量（178）来消除这些临时元素。引入参数对象（140）和保持对象完整（319）则可以将过长的参数列表变得更简洁一些。如果你已经这么做了，仍然有太多临时变量和参数，那就应该使出我们的杀手锏——以命令取代函数（337）。


### 引入参数对象（140）

我常会看见，一组数据项总是结伴同行，出没于一个又一个函数。这样一组数据就是所谓的数据泥团，我喜欢代之以一个数据结构。

将数据组织成结构是一件有价值的事，因为这让数据项之间的关系变得明晰。使用新的数据结构，参数的参数列表也能缩短。并且经过重构之后，所有使用该数据结构的函数都会通过同样的名字来访问其中的元素，从而提升代码的一致性。

![LOGO](/public/image/refactoring/IntroduceParameterObject.png)

### 保持对象完整（319）

如果我看见代码从一个记录结构中导出几个值，然后又把这几个值一起传递给一个函数，我会更愿意把整个记录传给这个函数，在函数体内部导出所需的值。

![LOGO](/public/image/refactoring/PreserveWholeObject.png)



### 以命令取代函数（337）

<sapn class="marker-text">函数，不管是独立函数，还是以方法（method）形式附着在对象上的函数，是程序设计的基本构造块。不过，将函数封装成自己的对象，有时也是一种有用的办法。这样的对象我称之为“命令对象”​（command object）​，或者简称“命令”​（command）​。这种对象大多只服务于单一函数，获得对该函数的请求，执行该函数，就是这种对象存在的意义。</sapn>

![LOGO](/public/image/refactoring/ReplaceFunctionWithCommand.png)




### 寻找注释

如何确定该提炼哪一段代码呢？一个很好的技巧是：<sapn class="marker-text">寻找注释。</sapn>它们通常能指出代码用途和实现手法之间的语义距离。如果代码前方有一行注释，就是在提醒你：可以将这段代码替换成一个函数，而且可以在注释的基础上给这个函数命名。就算只有一行代码，如果它需要以注释来说明，那也值得将它提炼到独立函数中去。

条件表达式和循环常常也是提炼的信号。你可以使用分解条件表达式（260）处理条件表达式。对于庞大的switch语句，其中的每个分支都应该通过提炼函数（106）变成独立的函数调用。如果有多个switch语句基于同一个条件进行分支选择，就应该使用以多态取代条件表达式（272）。


### 分解条件表达式（260）

程序之中，复杂的条件逻辑是最常导致复杂度上升的地点之一。

![LOGO](/public/image/refactoring/DecomposeConditional.png)

我必须编写代码来检查不同的条件分支，根据不同的条件做不同的事，然后，我很快就会得到一个相当长的函数。大型函数本身就会使代码的可读性下降，而条件逻辑则会使代码更难阅读。在带有复杂条件逻辑的函数中，代码（包括检查条件分支的代码和真正实现功能的代码）会告诉我发生的事，但常常让我弄不清楚为什么会发生这样的事，这就说明代码的可读性的确大大降低了。和任何大块头代码一样，<sapn class="marker-text">我可以将它分解为多个独立的函数，根据每个小块代码的用途，为分解而得的新函数命名，并将原函数中对应的代码改为调用新函数，从而更清楚地表达自己的意图。对于条件逻辑，将每个分支条件分解成新函数还可以带来更多好处：可以突出条件逻辑，更清楚地表明每个分支的作用，并且突出每个分支的原因。</sapn>



## 过长参数列表（Long Parameter List）


如果可以向某个参数发起查询而获得另一个参数的值，那么就可以使用以查询取代参数（324）去掉这第二个参数。

### 查询取代参数（324）

和任何代码中的语句一样，参数列表应该尽量避免重复，并且参数列表越短就越容易理解。

如果调用函数时传入了一个值，而这个值由函数自己来获得也是同样容易，这就是重复。这个本不必要的参数会增加调用者的难度，因为它不得不找出正确的参数值，其实原本调用者是不需要费这个力气的。“同样容易”四个字，划出了一条判断的界限。<sapn class="marker-text">去除参数也就意味着“获得正确的参数值”的责任被转移：有参数传入时，调用者需要负责获得正确的参数值；参数去除后，责任就被转移给了函数本身。一般而言，我习惯于简化调用方，因此我愿意把责任移交给函数本身，但如果函数难以承担这份责任，就另当别论了。</sapn>

![LOGO](/public/image/refactoring/ReplaceParameterWithQuery.png)

如果你发现自己正在从现有的数据结构中抽出很多数据项，就可以考虑使用保持对象完整（319）手法，直接传入原来的数据结构。



如果有几项参数总是同时出现，可以用引入参数对象（140）将其合并成一个对象。

如果某个参数被用作区分函数行为的标记（flag）​，可以使用移除标记参数（314）。

### 移除标记参数（314）

<sapn class="marker-text">只有调用者直接传入字面量值，这才是标记参数</sapn>。如果调用者传入的是程序中流动的数据，这样的参数不算标记参数。如果参数值只是作为数据传给其他函数，这就不是标记参数；<sapn class="marker-text">只有参数值影响了函数内部的控制流，这才是标记参数。</sapn>

```js

// 以布尔形式出现
bookConcert(aCustomer, true);

// 以枚举的形式出现：
bookConcert(aCustomer, CustomerType.PREMIUM);

// 或者是以字符串（或者符号，如果编程语言支持的话）的形式出现：
bookConcert(aCustomer, "premium");

```

![LOGO](/public/image/refactoring/RemoveFlagArgument.png)



### 函数组合成类（144）
 
 使用类可以有效地缩短参数列表。如果多个函数有同样的几个参数，引入一个类就尤为有意义。你可以使用函数组合成类（144），将这些共同的参数变成这个类的字段。


类，在大多数现代编程语言中都是基本的构造。它们把数据与函数捆绑到同一个环境中，将一部分数据与函数暴露给其他程序元素以便协作。它们是面向对象语言的首要构造，在其他程序设计方法中也同样有用。

<sapn class="marker-text">如果发现一组函数形影不离地操作同一块数据（通常是将这块数据作为参数传递给函数）​，我就认为，是时候组建一个类了。类能明确地给这些函数提供一个共用的环境，在对象内部调用这些函数可以少传许多参数，从而简化函数调用，并且这样一个对象也可以更方便地传递给系统的其他部分。</sapn>

![LOGO](/public/image/refactoring/CombineFunctionsIntoClass.png)



## 全局数据（Global Data）


全局数据的问题在于，从代码库的任何一个角落都可以修改它，而且没有任何机制可以探测出到底哪段代码做出了修改。


首要的防御手段是封装变量（132），每当我们看到可能被各处的代码污染的数据，这总是我们应对的第一招。你把全局数据用一个函数包装起来，至少你就能看见修改它的地方，并开始控制对它的访问。随后，最好将这个函数（及其封装的数据）搬移到一个类或模块中，只允许模块内的代码使用它，从而尽量控制其作用域。


### 封装变量（132）


<sapn class="marker-text">重构的作用就是调整程序中的元素。</sapn>函数相对容易调整一些，因为函数只有一种用法，就是调用。在改名或搬移函数的过程中，总是可以比较容易地保留旧函数作为转发函数（即旧代码调用旧函数，旧函数再调用新函数）​。这样的转发函数通常不会存在太久，但的确能够简化重构过程。


数据就要麻烦得多，因为没办法设计这样的转发机制。如果我把数据搬走，就必须同时修改所有引用该数据的代码，否则程序就不能运行。如果数据的可访问范围很小，比如一个小函数内部的临时变量，那还不成问题。但如果可访问范围变大，重构的难度就会随之增大，这也是说全局数据是大麻烦的原因。


<sapn class="marker-text">所以，如果想要搬移一处被广泛使用的数据，最好的办法往往是先以函数形式封装所有对该数据的访问。这样，我就能把“重新组织数据”的困难任务转化为“重新组织函数”这个相对简单的任务。</sapn>


![LOGO](/public/image/refactoring/EncapsulateVariable.png)

<sapn class="marker-text">用封装变量（132）来确保所有数据更新操作都通过很少几个函数来进行</sapn>

## 可变数据（Mutable Data）

<sapn class="marker-text">对数据的修改经常导致出乎意料的结果和难以发现的bug。我在一处更新数据，却没有意识到软件中的另一处期望着完全不同的数据，于是一个功能失效了——如果故障只在很罕见的情况下发生，要找出故障原因就会更加困难。</sapn>因此，有一整个软件开发流派——函数式编程——完全建立在“数据永不改变”的概念基础上：如果要更新一个数据结构，就返回一份新的数据副本，旧的数据仍保持不变。


可以用封装变量（132）来确保所有数据更新操作都通过很少几个函数来进行，使其更容易监控和演进

### 拆分变量（240）

如果一个变量在不同时候被用于存储不同的东西，可以使用拆分变量（240）将其拆分为各自不同用途的变量，从而避免危险的更新操作。

变量有各种不同的用途，其中某些用途会很自然地导致临时变量被多次赋值。​“循环变量”和“结果收集变量”就是两个典型例子：循环变量（loop variable）会随循环的每次运行而改变（例如for（let i=0; i<10; i++）语句中的i）​；结果收集变量（collecting variable）负责将“通过整个函数的运算”而构成的某个值收集起来。


除了这两种情况，还有很多变量用于保存一段冗长代码的运算结果，以便稍后使用。这种变量应该只被赋值一次。如果它们被赋值超过一次，就意味它们在函数中承担了一个以上的责任。如果变量承担多个责任，它就应该被替换（分解）为多个变量，每个变量只承担一个责任。同一个变量承担两件不同的事情，会令代码阅读者糊涂。

![LOGO](/public/image/refactoring/SplitVariable.png)


使用移动语句（223）和提炼函数（106）尽量把逻辑从处理更新操作的代码中搬移出来，将没有副作用的代码与执行数据更新操作的代码分开。

### 将查询函数和修改函数分离（306）

设计API时，可以使用将查询函数和修改函数分离（306）确保调用者不会调到有副作用的代码，除非他们真的需要更新数据。

![LOGO](/public/image/refactoring/SeparateQueryFromModifier.png)


### 使用移除设值函数（331）

我们还乐于尽早使用移除设值函数（331）——有时只是把设值函数的使用者找出来看看，就能帮我们发现缩小变量作用域的机会


![LOGO](/public/image/refactoring/RemoveSettingMethod.png)

### 函数组合成变换（149）

如果变量作用域只有几行代码，即使其中的数据可变，也不是什么大问题；但随着变量作用域的扩展，风险也随之增大。可以用函数组合成类（144）或者函数组合成变换（149）来限制需要对变量进行修改的代码量

在软件中，经常需要把数据“喂”给一个程序，让它再计算出各种派生信息。这些派生数值可能会在几个不同地方用到，因此这些计算逻辑也常会在用到派生数据的地方重复。我更愿意把所有计算派生数据的逻辑收拢到一处，这样始终可以在固定的地方找到和更新这些逻辑，避免到处重复。

一个方式是采用数据变换（transform）函数：这种函数接受源数据作为输入，计算出所有的派生数据，将派生数据以字段形式填入输出数据。有了变换函数，我就始终只需要到变换函数中去检查计算派生数据的逻辑。


![LOGO](/public/image/refactoring/CombineFunctionsIntoTransform.png)


### 将引用对象改为值对象（252）

如果一个变量在其内部结构中包含了数据，通常最好不要直接修改其中的数据，而是用将引用对象改为值对象（252）令其直接替换整个数据结构。


在把一个对象（或数据结构）嵌入另一个对象时，位于内部的这个对象可以被视为引用对象，也可以被视为值对象。

![LOGO](/public/image/refactoring/ChangeReferenceToValue.png)

## 发散式变化（Divergent Change）