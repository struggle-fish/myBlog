# 代码坏味道

## 神秘命名（Mysterious Name）

整洁代码最重要的一环就是好的名字，所以我们会深思熟虑如何给函数、模块、变量和类命名，使它们能清晰地表明自己的功能和用法。命名是编程中最难的两件事之一[mf-2h]​。正因为如此，改名可能是最常用的重构手法，包括改变函数声明（124）（用于给函数改名）​、变量改名（137）、字段改名（244）等。

> 变量改名（137）

![LOGO](/public/image/refactoring/RenameVariable.png)

好的命名是整洁编程的核心。变量可以很好地解释一段程序在干什么——如果变量名起得好的话。使用范围越广，名字的好坏就越重要。只在一行的lambda表达式中使用的变量，跟踪起来很容易——像这样的变量，我经常只用一个字母命名，因为变量的用途在这个上下文中很清晰。同理，短函数的参数名也常常很简单。不过在JavaScript这样的动态类型语言中，我喜欢把类型信息也放进名字里（于是变量名可能叫`aCustomer`）​。

> 字段改名（244）

![LOGO](/public/image/refactoring/RenameField.png)



## 重复代码（Duplicated Code）

如果你在一个以上的地点看到相同的代码结构，那么可以肯定：<sapn class="marker-text">设法将它们合而为一，程序会变得更好。一旦有重复代码存在，阅读这些重复的代码时你就必须加倍仔细，留意其间细微的差异。如果要修改重复代码，你必须找出所有的副本来修改。</sapn>



## 过长函数（Long Function）


据我们的经验，活得最长、最好的程序，其中的函数都比较短。初次接触到这种代码库的程序员常常会觉得“计算都没有发生”——程序里满是无穷无尽的委托调用。但和这样的程序共处几年之后，你就会明白这些小函数的价值所在。间接性带来的好处——更好的阐释力、更易于分享、更多的选择——都是由小函数来支持的。


<sapn class="marker-text">最终的效果是：你应该更积极地分解函数。我们遵循这样一条原则：每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名。我们可以对一组甚至短短一行代码做这件事。哪怕替换后的函数调用动作比函数自身还长，只要函数名称能够解释其用途，我们也该毫不犹豫地那么做。关键不在于函数的长度，而在于函数“做什么”和“如何做”之间的语义距离。</sapn>


百分之九十九的场合里，要把函数变短，只需使用提炼函数（106）。找到函数中适合集中在一起的部分，将它们提炼出来形成一个新函数。

如果函数内有大量的参数和临时变量，它们会对你的函数提炼形成阻碍。如果你尝试运用提炼函数（106），最终就会把许多参数传递给被提炼出来的新函数，导致可读性几乎没有任何提升。此时，你可以经常运用以查询取代临时变量（178）来消除这些临时元素。引入参数对象（140）和保持对象完整（319）则可以将过长的参数列表变得更简洁一些。如果你已经这么做了，仍然有太多临时变量和参数，那就应该使出我们的杀手锏——以命令取代函数（337）。


### 引入参数对象（140）

我常会看见，一组数据项总是结伴同行，出没于一个又一个函数。这样一组数据就是所谓的数据泥团，我喜欢代之以一个数据结构。

将数据组织成结构是一件有价值的事，因为这让数据项之间的关系变得明晰。使用新的数据结构，参数的参数列表也能缩短。并且经过重构之后，所有使用该数据结构的函数都会通过同样的名字来访问其中的元素，从而提升代码的一致性。

![LOGO](/public/image/refactoring/IntroduceParameterObject.png)

### 保持对象完整（319）

如果我看见代码从一个记录结构中导出几个值，然后又把这几个值一起传递给一个函数，我会更愿意把整个记录传给这个函数，在函数体内部导出所需的值。

![LOGO](/public/image/refactoring/PreserveWholeObject.png)



### 以命令取代函数（337）

<sapn class="marker-text">函数，不管是独立函数，还是以方法（method）形式附着在对象上的函数，是程序设计的基本构造块。不过，将函数封装成自己的对象，有时也是一种有用的办法。这样的对象我称之为“命令对象”​（command object）​，或者简称“命令”​（command）​。这种对象大多只服务于单一函数，获得对该函数的请求，执行该函数，就是这种对象存在的意义。</sapn>

![LOGO](/public/image/refactoring/ReplaceFunctionWithCommand.png)




### 寻找注释

如何确定该提炼哪一段代码呢？一个很好的技巧是：<sapn class="marker-text">寻找注释。</sapn>它们通常能指出代码用途和实现手法之间的语义距离。如果代码前方有一行注释，就是在提醒你：可以将这段代码替换成一个函数，而且可以在注释的基础上给这个函数命名。就算只有一行代码，如果它需要以注释来说明，那也值得将它提炼到独立函数中去。

条件表达式和循环常常也是提炼的信号。你可以使用分解条件表达式（260）处理条件表达式。对于庞大的switch语句，其中的每个分支都应该通过提炼函数（106）变成独立的函数调用。如果有多个switch语句基于同一个条件进行分支选择，就应该使用以多态取代条件表达式（272）。


### 分解条件表达式（260）

程序之中，复杂的条件逻辑是最常导致复杂度上升的地点之一。

![LOGO](/public/image/refactoring/DecomposeConditional.png)

我必须编写代码来检查不同的条件分支，根据不同的条件做不同的事，然后，我很快就会得到一个相当长的函数。大型函数本身就会使代码的可读性下降，而条件逻辑则会使代码更难阅读。在带有复杂条件逻辑的函数中，代码（包括检查条件分支的代码和真正实现功能的代码）会告诉我发生的事，但常常让我弄不清楚为什么会发生这样的事，这就说明代码的可读性的确大大降低了。和任何大块头代码一样，<sapn class="marker-text">我可以将它分解为多个独立的函数，根据每个小块代码的用途，为分解而得的新函数命名，并将原函数中对应的代码改为调用新函数，从而更清楚地表达自己的意图。对于条件逻辑，将每个分支条件分解成新函数还可以带来更多好处：可以突出条件逻辑，更清楚地表明每个分支的作用，并且突出每个分支的原因。</sapn>



## 过长参数列表（Long Parameter List）


如果可以向某个参数发起查询而获得另一个参数的值，那么就可以使用以查询取代参数（324）去掉这第二个参数。

### 查询取代参数（324）

和任何代码中的语句一样，参数列表应该尽量避免重复，并且参数列表越短就越容易理解。

如果调用函数时传入了一个值，而这个值由函数自己来获得也是同样容易，这就是重复。这个本不必要的参数会增加调用者的难度，因为它不得不找出正确的参数值，其实原本调用者是不需要费这个力气的。“同样容易”四个字，划出了一条判断的界限。<sapn class="marker-text">去除参数也就意味着“获得正确的参数值”的责任被转移：有参数传入时，调用者需要负责获得正确的参数值；参数去除后，责任就被转移给了函数本身。一般而言，我习惯于简化调用方，因此我愿意把责任移交给函数本身，但如果函数难以承担这份责任，就另当别论了。</sapn>

![LOGO](/public/image/refactoring/ReplaceParameterWithQuery.png)

如果你发现自己正在从现有的数据结构中抽出很多数据项，就可以考虑使用保持对象完整（319）手法，直接传入原来的数据结构。



如果有几项参数总是同时出现，可以用引入参数对象（140）将其合并成一个对象。

如果某个参数被用作区分函数行为的标记（flag）​，可以使用移除标记参数（314）。

### 移除标记参数（314）

<sapn class="marker-text">只有调用者直接传入字面量值，这才是标记参数</sapn>。如果调用者传入的是程序中流动的数据，这样的参数不算标记参数。如果参数值只是作为数据传给其他函数，这就不是标记参数；<sapn class="marker-text">只有参数值影响了函数内部的控制流，这才是标记参数。</sapn>

```js

// 以布尔形式出现
bookConcert(aCustomer, true);

// 以枚举的形式出现：
bookConcert(aCustomer, CustomerType.PREMIUM);

// 或者是以字符串（或者符号，如果编程语言支持的话）的形式出现：
bookConcert(aCustomer, "premium");

```

![LOGO](/public/image/refactoring/RemoveFlagArgument.png)



### 函数组合成类（144）
 
 使用类可以有效地缩短参数列表。如果多个函数有同样的几个参数，引入一个类就尤为有意义。你可以使用函数组合成类（144），将这些共同的参数变成这个类的字段。


类，在大多数现代编程语言中都是基本的构造。它们把数据与函数捆绑到同一个环境中，将一部分数据与函数暴露给其他程序元素以便协作。它们是面向对象语言的首要构造，在其他程序设计方法中也同样有用。

<sapn class="marker-text">如果发现一组函数形影不离地操作同一块数据（通常是将这块数据作为参数传递给函数）​，我就认为，是时候组建一个类了。类能明确地给这些函数提供一个共用的环境，在对象内部调用这些函数可以少传许多参数，从而简化函数调用，并且这样一个对象也可以更方便地传递给系统的其他部分。</sapn>

![LOGO](/public/image/refactoring/CombineFunctionsIntoClass.png)



## 全局数据（Global Data）


全局数据的问题在于，从代码库的任何一个角落都可以修改它，而且没有任何机制可以探测出到底哪段代码做出了修改。


首要的防御手段是封装变量（132），每当我们看到可能被各处的代码污染的数据，这总是我们应对的第一招。你把全局数据用一个函数包装起来，至少你就能看见修改它的地方，并开始控制对它的访问。随后，最好将这个函数（及其封装的数据）搬移到一个类或模块中，只允许模块内的代码使用它，从而尽量控制其作用域。


### 封装变量（132）


<sapn class="marker-text">重构的作用就是调整程序中的元素。</sapn>函数相对容易调整一些，因为函数只有一种用法，就是调用。在改名或搬移函数的过程中，总是可以比较容易地保留旧函数作为转发函数（即旧代码调用旧函数，旧函数再调用新函数）​。这样的转发函数通常不会存在太久，但的确能够简化重构过程。


数据就要麻烦得多，因为没办法设计这样的转发机制。如果我把数据搬走，就必须同时修改所有引用该数据的代码，否则程序就不能运行。如果数据的可访问范围很小，比如一个小函数内部的临时变量，那还不成问题。但如果可访问范围变大，重构的难度就会随之增大，这也是说全局数据是大麻烦的原因。


<sapn class="marker-text">所以，如果想要搬移一处被广泛使用的数据，最好的办法往往是先以函数形式封装所有对该数据的访问。这样，我就能把“重新组织数据”的困难任务转化为“重新组织函数”这个相对简单的任务。</sapn>


![LOGO](/public/image/refactoring/EncapsulateVariable.png)

<sapn class="marker-text">用封装变量（132）来确保所有数据更新操作都通过很少几个函数来进行</sapn>

## 可变数据（Mutable Data）

<sapn class="marker-text">对数据的修改经常导致出乎意料的结果和难以发现的bug。我在一处更新数据，却没有意识到软件中的另一处期望着完全不同的数据，于是一个功能失效了——如果故障只在很罕见的情况下发生，要找出故障原因就会更加困难。</sapn>因此，有一整个软件开发流派——函数式编程——完全建立在“数据永不改变”的概念基础上：如果要更新一个数据结构，就返回一份新的数据副本，旧的数据仍保持不变。


可以用封装变量（132）来确保所有数据更新操作都通过很少几个函数来进行，使其更容易监控和演进

### 拆分变量（240）

如果一个变量在不同时候被用于存储不同的东西，可以使用拆分变量（240）将其拆分为各自不同用途的变量，从而避免危险的更新操作。

变量有各种不同的用途，其中某些用途会很自然地导致临时变量被多次赋值。​“循环变量”和“结果收集变量”就是两个典型例子：循环变量（loop variable）会随循环的每次运行而改变（例如for（let i=0; i<10; i++）语句中的i）​；结果收集变量（collecting variable）负责将“通过整个函数的运算”而构成的某个值收集起来。


除了这两种情况，还有很多变量用于保存一段冗长代码的运算结果，以便稍后使用。这种变量应该只被赋值一次。如果它们被赋值超过一次，就意味它们在函数中承担了一个以上的责任。如果变量承担多个责任，它就应该被替换（分解）为多个变量，每个变量只承担一个责任。同一个变量承担两件不同的事情，会令代码阅读者糊涂。

![LOGO](/public/image/refactoring/SplitVariable.png)


使用移动语句（223）和提炼函数（106）尽量把逻辑从处理更新操作的代码中搬移出来，将没有副作用的代码与执行数据更新操作的代码分开。

### 将查询函数和修改函数分离（306）

设计API时，可以使用将查询函数和修改函数分离（306）确保调用者不会调到有副作用的代码，除非他们真的需要更新数据。

![LOGO](/public/image/refactoring/SeparateQueryFromModifier.png)


### 使用移除设值函数（331）

我们还乐于尽早使用移除设值函数（331）——有时只是把设值函数的使用者找出来看看，就能帮我们发现缩小变量作用域的机会


![LOGO](/public/image/refactoring/RemoveSettingMethod.png)

### 函数组合成变换（149）

如果变量作用域只有几行代码，即使其中的数据可变，也不是什么大问题；但随着变量作用域的扩展，风险也随之增大。可以用函数组合成类（144）或者函数组合成变换（149）来限制需要对变量进行修改的代码量

在软件中，经常需要把数据“喂”给一个程序，让它再计算出各种派生信息。这些派生数值可能会在几个不同地方用到，因此这些计算逻辑也常会在用到派生数据的地方重复。我更愿意把所有计算派生数据的逻辑收拢到一处，这样始终可以在固定的地方找到和更新这些逻辑，避免到处重复。

一个方式是采用数据变换（transform）函数：这种函数接受源数据作为输入，计算出所有的派生数据，将派生数据以字段形式填入输出数据。有了变换函数，我就始终只需要到变换函数中去检查计算派生数据的逻辑。


![LOGO](/public/image/refactoring/CombineFunctionsIntoTransform.png)


### 将引用对象改为值对象（252）

如果一个变量在其内部结构中包含了数据，通常最好不要直接修改其中的数据，而是用将引用对象改为值对象（252）令其直接替换整个数据结构。


在把一个对象（或数据结构）嵌入另一个对象时，位于内部的这个对象可以被视为引用对象，也可以被视为值对象。

![LOGO](/public/image/refactoring/ChangeReferenceToValue.png)

## 发散式变化（Divergent Change）

如果某个模块经常因为不同的原因在不同的方向上发生变化，发散式变化就出现了。当你看着一个类说：​“呃，如果新加入一个数据库，我必须修改这3个函数；如果新出现一种金融工具，我必须修改这4个函数。​”这就是发散式变化的征兆。


如果发生变化的两个方向自然地形成了先后次序（比如说，先从数据库取出数据，再对其进行金融逻辑处理）​，就可以用拆分阶段（154）将两者分开，两者之间通过一个清晰的数据结构进行沟通。


如果两个方向之间有更多的来回调用，就应该先创建适当的模块，然后用搬移函数（198）把处理逻辑分开。

如果函数内部混合了两类处理逻辑，应该先用提炼函数（106）将其分开，然后再做搬移。


如果模块是以类的形式定义的，就可以用提炼类（182）来做拆分。

### 提炼类（182）

你也许听过类似这样的建议：一个类应该是一个清晰的抽象，只处理一些明确的责任，等等。但是在实际工作中，类会不断成长扩展。你会在这儿加入一些功能，在那儿加入一些数据。给某个类添加一项新责任时，你会觉得不值得为这项责任分离出一个独立的类。于是，随着责任不断增加，这个类会变得过分复杂。很快，你的类就会变成一团乱麻。

<sapn class="marker-text">设想你有一个维护大量函数和数据的类。这样的类往往因为太大而不易理解。此时你需要考虑哪些部分可以分离出去，并将它们分离到一个独立的类中。如果某些数据和某些函数总是一起出现，某些数据经常同时变化甚至彼此相依，这就表示你应该将它们分离出去。一个有用的测试就是问你自己，如果你搬移了某些字段和函数，会发生什么事？其他字段和函数是否因此变得无意义？</sapn >

![LOGO](/public/image/refactoring/ExtractClass.png)

## 霰弹式修改（Shotgun Surgery）

霰弹式修改类似于发散式变化，但又恰恰相反。如果每遇到某种变化，你都必须在许多不同的类内做出许多小修改，你所面临的坏味道就是霰弹式修改。如果需要修改的代码散布四处，你不但很难找到它们，也很容易错过某个重要的修改。

这种情况下，你应该使用搬移函数（198）和搬移字段（207）把所有需要修改的代码放进同一个模块里

### 搬移字段（207）

![LOGO](/public/image/refactoring/MoveField.png)

如果有很多函数都在操作相似的数据，可以使用函数组合成类（144）。

如果有很多函数都在操作相似的数据，可以使用函数组合成类（144）。


如果一些函数的输出可以组合后提供给一段专门使用这些计算结果的逻辑，这种时候常常用得上拆分阶段（154）。


面对霰弹式修改，一个常用的策略就是使用与内联（inline）相关的重构——如内联函数（115）或是内联类（186）——把本不该分散的逻辑拽回一处。


### 内联类（186）


![LOGO](/public/image/refactoring/InlineClass.png)

## 依恋情结（Feature Envy）

<sapn class="marker-text">所谓模块化，就是力求将代码分出区域，最大化区域内部的交互、最小化跨区域的交互。</sapn >但有时你会发现，一个函数跟另一个模块中的函数或者数据交流格外频繁，远胜于在自己所处模块内部的交流，这就是依恋情结的典型情况。


无数次经验里，我们看到某个函数为了计算某个值，从另一个对象那儿调用几乎半打的取值函数。疗法显而易见：这个函数想跟这些数据待在一起，那就使用搬移函数（198）把它移过去。

有时候，函数中只有一部分受这种依恋之苦，这时候应该使用提炼函数（106）把这一部分提炼到独立的函数中，再使用搬移函数（198）带它去它的梦想家园。




<sapn class="marker-text">最根本的原则是：将总是一起变化的东西放在一块儿。数据和引用这些数据的行为总是一起变化的</sapn >


## 数据泥团（Data Clumps）

数据项就像小孩子，喜欢成群结队地待在一块儿。

你常常可以在很多地方看到相同的三四项数据：两个类中相同的字段、许多函数签名中相同的参数。这些总是绑在一起出现的数据真应该拥有属于它们自己的对象。首先请找出这些数据以字段形式出现的地方，运用提炼类（182）将它们提炼到一个独立对象中。

然后将注意力转移到函数签名上，运用引入参数对象（140）或保持对象完整（319）为它瘦身。


一个好的评判办法是：删掉众多数据中的一项。如果这么做，其他数据有没有因而失去意义？如果它们不再有意义，这就是一个明确信号：你应该为它们产生一个新对象。


## 基本类型偏执（Primitive Obsession）

大多数编程环境都大量使用基本类型，即整数、浮点数和字符串等。


你可以运用以对象取代基本类型（174）将原本单独存在的数据值替换为对象，从而走出传统的洞窟，进入炙手可热的对象世界。

### 以对象取代基本类型（174）

![LOGO](/public/image/refactoring/ReplacePrimitiveWithObject.png)



如果想要替换的数据值是控制条件行为的类型码，则可以运用以子类取代类型码（362）加上以多态取代条件表达式（272）的组合将它换掉。


如果你有一组总是同时出现的基本类型数据，这就是数据泥团的征兆，应该运用提炼类（182）和引入参数对象（140）来处理。


## 重复的switch （Repeated Switches）

如果你跟真正的面向对象布道者交谈，他们很快就会谈到switch语句的邪恶。在他们看来，任何switch语句都应该用以多态取代条件表达式（272）消除掉。

## 循环语句（Loops）


函数作为一等公民已经得到了广泛的支持，因此我们可以使用以管道取代循环（231）来让这些老古董退休。我们发现，管道操作（如filter和map）可以帮助我们更快地看清被处理的元素以及处理它们的动作。

## 冗赘的元素（Lazy Element）


程序元素（如类和函数）能给代码增加结构，从而支持变化、促进复用或者哪怕只是提供更好的名字也好，但有时我们真的不需要这层额外的结构。可能有这样一个函数，它的名字就跟实现代码看起来一模一样；也可能有这样一个类，根本就是一个简单的函数。这可能是因为，起初在编写这个函数时，程序员也许期望它将来有一天会变大、变复杂，但那一天从未到来；也可能是因为，这个类原本是有用的，但随着重构的进行越变越小，最后只剩了一个函数。

不论上述哪一种原因，请让这样的程序元素庄严赴义吧。通常你只需要使用内联函数（115）或是内联类（186）。如果这个类处于一个继承体系中，可以使用折叠继承体系（380）。

### 折叠继承体系（380）

在重构类继承体系时，我经常把函数和字段上下移动。随着继承体系的演化，我有时会发现一个类与其超类已经没多大差别，不值得再作为独立的类存在。此时我就会把超类和子类合并起来。

![LOGO](/public/image/refactoring/CollapseHierarchy.png)


## 夸夸其谈通用性（Speculative Generality）


如果你的某个抽象类其实没有太大作用，请运用折叠继承体系（380）。

不必要的委托可运用内联函数（115）和内联类（186）除掉。

如果函数的某些参数未被用上，可以用改变函数声明（124）去掉这些参数,如果有并非真正需要、只是为不知远在何处的将来而塞进去的参数，也应该用改变函数声明（124）去掉。


如果函数或类的唯一用户是测试用例，这就飘出了坏味道“夸夸其谈通用性”​。如果你发现这样的函数或类，可以先删掉测试用例，然后使用移除死代码（237）。

### 移除死代码（237）

![LOGO](/public/image/refactoring/RemoveDeadCode.png)

## 临时字段（Temporary Field）


请使用提炼类（182）给这个可怜的孤儿创造一个家，然后用搬移函数（198）把所有和这些字段相关的代码都放进这个新家。也许你还可以使用引入特例（289）在“变量不合法”的情况下创建一个替代对象，从而避免写出条件式代码。

### 引入特例（289）

一种常见的重复代码是这种情况：一个数据结构的使用者都在检查某个特殊的值，并且当这个特殊值出现时所做的处理也都相同。如果我发现代码库中有多处以同样方式应对同一个特殊值，我就会想要把这个处理逻辑收拢到一处

![LOGO](/public/image/refactoring/IntroduceSpecialCase.png)





## 过长的消息链（Message Chains）

如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象……这就是消息链。

这时候应该使用隐藏委托关系（189）。你可以在消息链的不同位置采用这种重构手法。

### 隐藏委托关系（189）

一个好的模块化的设计，​“封装”即使不是其最关键特征，也是最关键特征之一。​“封装”意味着每个模块都应该尽可能少了解系统的其他部分。如此一来，一旦发生变化，需要了解这一变化的模块就会比较少——这会使变化比较容易进行。

![LOGO](/public/image/refactoring/HideDelegate.png)


理论上，你可以重构消息链上的所有对象，但这么做就会把所有中间对象都变成“中间人”​。通常更好的选择是：先观察消息链最终得到的对象是用来干什么的，看看能否以提炼函数（106）把使用该对象的代码提炼到一个独立的函数中，再运用搬移函数（198）把这个函数推入消息链。如果还有许多客户端代码需要访问链上的其他对象，同样添加一个函数来完成此事。


## 中间人（Middle Man）

<sapn class="marker-text">对象的基本特征之一就是封装——对外部世界隐藏其内部细节。封装往往伴随着委托。</sapn >比如，你问主管是否有时间参加一个会议，他就把这个消息“委托”给他的记事簿，然后才能回答你。很好，你没必要知道这位主管到底使用传统记事簿还是使用电子记事簿抑或是秘书来记录自己的约会。



但是人们可能过度运用委托。你也许会看到某个类的接口有一半的函数都委托给其他类，这样就是过度运用。这时应该使用移除中间人（192），直接和真正负责的对象打交道。


### 移除中间人（192）

![LOGO](/public/image/refactoring/RemoveMiddleMan.png)


如果这样“不干实事”的函数只有少数几个，可以运用内联函数（115）把它们放进调用端。


如果这些中间人还有其他行为，可以运用以委托取代超类（399）或者以委托取代子类（381）把它变成真正的对象，这样你既可以扩展原对象的行为，又不必负担那么多的委托动作。



### 以委托取代超类（399）

在面向对象程序中，通过继承来复用现有功能，是一种既强大又便捷的手段。我只要继承一个已有的类，覆写一些功能，再添加一些功能，就能达成目的。但继承也有可能造成困扰和混乱。


在对象技术发展早期，有一个经典的误用继承的例子：让栈（stack）继承列表（list）​。这个想法的出发点是想复用列表类的数据存储和操作能力。虽说复用是一件好事，但这个继承关系有问题：列表类的所有操作都会出现在栈类的接口上，然而其中大部分操作对一个栈来说并不适用。更好的做法应该是把列表作为栈的字段，把必要的操作委派给列表就行了。

![LOGO](/public/image/refactoring/ReplaceSuperclassWithDelegate.png)


### 以委托取代子类（381）

如果一个对象的行为有明显的类别之分，继承是很自然的表达方式。我可以把共用的数据和行为放在超类中，每个子类根据需要覆写部分特性。在面向对象语言中，继承很容易实现，因此也是程序员熟悉的机制。

<sapn class="marker-text">但继承也有其短板。最明显的是，继承这张牌只能打一次。导致行为不同的原因可能有多种，但继承只能用于处理一个方向上的变化。比如说，我可能希望“人”的行为根据“年龄段”不同，并且根据“收入水平”不同。使用继承的话，子类可以是“年轻人”和“老人”​，也可以是“富人”和“穷人”​，但不能同时采用两种继承方式。</sapn >

![LOGO](/public/image/refactoring/ReplaceSubclassWithDelegate.png)


## 内幕交易（Insider Trading）

软件开发者喜欢在模块之间建起高墙，极其反感在模块之间大量交换数据，因为这会增加模块间的耦合。在实际情况里，一定的数据交换不可避免，但我们必须尽量减少这种情况，并把这种交换都放到明面上来。

如果两个模块总是在咖啡机旁边窃窃私语，就应该用搬移函数（198）和搬移字段（207）减少它们的私下交流。


如果两个模块有共同的兴趣，可以尝试再新建一个模块，把这些共用的数据放在一个管理良好的地方；或者用隐藏委托关系（189），把另一个模块变成两者的中介。


继承常会造成密谋，因为子类对超类的了解总是超过后者的主观愿望。如果你觉得该让这个孩子独立生活了，请运用以委托取代子类（381）或以委托取代超类（399）让它离开继承体系。


## 过大的类（Large Class）

你可以运用提炼类（182）将几个变量一起提炼至新类内。提炼时应该选择类内彼此相关的变量，将它们放在一起


如果这个组件适合作为一个子类，你会发现提炼超类（375）或者以子类取代类型码（362）（其实就是提炼子类）往往比较简单。

### 提炼超类（375）

![LOGO](/public/image/refactoring/ExtractSuperclass.png)


观察一个大类的使用者，经常能找到如何拆分类的线索。看看使用者是否只用到了这个类所有功能的一个子集，每个这样的子集都可能拆分成一个独立的类。一旦识别出一个合适的功能子集，就试用提炼类（182）、提炼超类（375）或是以子类取代类型码（362）将其拆分出来。


## 异曲同工的类（Alternative Classes with Different Interfaces）

使用类的好处之一就在于可以替换：今天用这个类，未来可以换成用另一个类。但只有当两个类的接口一致时，才能做这种替换。可以用改变函数声明（124）将函数签名变得一致。但这往往还不够，请反复运用搬移函数（198）将某些行为移入类中，直到两者的协议一致为止。如果搬移过程造成了重复代码，或许可运用提炼超类（375）补偿一下。


## 纯数据类（Data Class）

所谓纯数据类是指：它们拥有一些字段，以及用于访问（读写）这些字段的函数，除此之外一无长物。这样的类只是一种不会说话的数据容器，它们几乎一定被其他类过分细琐地操控着

若果真如此，你应该在别人注意到它们之前，立刻运用封装记录（162）将它们封装起来。对于那些不该被其他类修改的字段，请运用移除设值函数（331）。


### 封装记录（162）

![LOGO](/public/image/refactoring/EncapsulateRecord.png)


然后，找出这些取值/设值函数被其他类调用的地点。尝试以搬移函数（198）把那些调用行为搬移到纯数据类里来。如果无法搬移整个函数，就运用提炼函数（106）产生一个可被搬移的函数。


## 被拒绝的遗赠（Refused Bequest）

子类应该继承超类的函数和数据。但如果它们不想或不需要继承，又该怎么办呢？它们得到所有礼物，却只从中挑选几样来玩！


按传统说法，这就意味着继承体系设计错误。你需要为这个子类新建一个兄弟类，再运用函数下移（359）和字段下移（361）把所有用不到的函数下推给那个兄弟。这样一来，超类就只持有所有子类共享的东西。你常常会听到这样的建议：所有超类都应该是抽象（abstract）的。

### 函数下移（359）

![LOGO](/public/image/refactoring/PushDownMethod.png)


### 字段下移（361）

![LOGO](/public/image/refactoring/PushDownField.png)


## 注释（Comments）

如果你需要注释来解释一块代码做了什么，试试提炼函数（106）；

如果函数已经提炼出来，但还是需要注释来解释其行为，试试用改变函数声明（124）为它改名；

如果你需要注释说明某些系统的需求规格，试试引入断言（302）。

### 引入断言（302）

![LOGO](/public/image/refactoring/IntroduceAssertion.png)


当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余。如果你不知道该做什么，这才是注释的良好运用时机。除了用来记述将来的打算之外，注释还可以用来标记你并无十足把握的区域。你可以在注释里写下自己“为什么做某某事”​。这类信息可以帮助将来的修改者，尤其是那些健忘的家伙。

