# 重构原则

## 何为重构


重构（名词）​：对软件内部结构的一种调整，<sapn class="marker-text">目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。</sapn>


重构（动词）​：<sapn class="marker-text">使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。</sapn>


重构的关键在于运用大量微小且保持软件行为的步骤，一步步达成大规模的修改，每个单独的重构要么很小，要么由若干小步骤组合而成。因此，在重构的过程中，我的代码很少进入不可工作的状态，即便重构没有完成，我也可以在任何时刻停下来。

::: warning 警告
如果有人说他们的代码在重构过程中有一两天时间不可用，基本上可以确定，他们在做的事不是重构。
:::



“可观察行为”的说法。它的意思是，整体而言，经过重构之后的代码所做的事应该与重构之前大致一样。<sapn class="marker-text">重构之后的代码不一定与重构前行为完全一致。</sapn>比如说，提炼函数（106）会改变函数调用栈，因此程序的性能就会有所改变；改变函数声明（124）和搬移函数（198）等重构经常会改变模块的接口。不过就用户应该关心的行为而言，不应该有任何改变。如果我在重构过程中发现了任何bug，重构完成后同样的bug应该仍然存在（不过，如果潜在的bug还没有被任何人发现，也可以当即把它改掉）​。

## 为何重构

重构是一个工具，它可以（并且应该）用于以下几个目的。

### 重构改进软件的设计

如果没有重构，程序的内部设计（或者叫架构）会逐渐腐败变质。哈哈，这句话我看到的时候真的，首先想到的是这不就是屎山吗。


完成同样一件事，设计欠佳的程序往往需要更多代码，<sapn class="marker-text">这常常是因为代码在不同的地方使用完全相同的语句做同样的事，因此改进设计的一个重要方向就是消除重复代码。</sapn>

<sapn class="marker-text">消除重复代码，我就可以确定所有事物和行为在代码中只表述一次，这正是优秀设计的根本。</sapn>


### 重构使软件更容易理解


所谓程序设计，很大程度上就是与计算机对话：我编写代码告诉计算机做什么事，而它的响应是按照我的指示精确行动。一言以蔽之，我所做的就是填补“我想要它做什么”和“我告诉它做什么”之间的缝隙。编程的核心就在于“准确说出我想要的”​。然而别忘了，<sapn class="marker-text">除了计算机外，源码还有其他读者：几个月之后可能会有另一位程序员尝试读懂我的代码并对其做一些修改。我们很容易忘记这这位读者，但他才是最重要的。</sapn>计算机是否多花了几个时钟周期来编译，又有什么关系呢？<sapn class="marker-text">如果一个程序员花费一周时间来修改某段代码，那才要命呢——如果他理解了我的代码，这个修改原本只需一小时。</sapn>


### 重构帮助找到bug

如果对代码进行重构，我就可以深入理解代码的所作所为，并立即把新的理解反映在代码当中。搞清楚程序结构的同时，我也验证了自己所做的一些假设，于是想不把bug揪出来都难。

<sapn class="marker-text">我不是一个特别好的程序员，我只是一个有着一些特别好的习惯的还不错的程序员。</sapn>重构能够帮助我更有效地写出健壮的代码。

### 重构提高编程速度

最后，前面的一切都归结到了这一点：重构帮我更快速地开发程序。


## 何时重构


### 三次法则

Don Roberts给了我一条准则：<sapn class="marker-text">第一次做某件事时只管去做；第二次做类似的事会产生反感，但无论如何还是可以去做；第三次再做类似的事，你就应该重构。</sapn>

### 让添加新功能更容易

重构的最佳时机就在添加新功能之前。

在动手添加新功能之前，我会看看现有的代码库，此时经常会发现：如果对代码结构做一点微调，我的工作会容易得多。也许已经有个函数提供了我需要的大部分功能，但有几个字面量的值与我的需要略有冲突。如果不做重构，我可能会把整个函数复制过来，修改这几个值，但这就会导致重复代码——如果将来我需要做修改，就必须同时修改两处（更麻烦的是，我得先找到这两处）​。而且，如果将来我还需要一个类似又略有不同的功能，就只能再复制粘贴一次，这可不是个好主意。所以我戴上重构的帽子，使用函数参数化（310）。做完这件事以后，接下来我就只需要调用这个函数，传入我需要的参数。


> 函数参数化（310）

如果我发现两个函数逻辑非常相似，只有一些字面量值不同，可以将其合并成一个函数，以参数的形式传入不同的值，从而消除重复。这个重构可以使函数更有用，因为重构后的函数还可以用于处理其他的值。


![LOGO](/public/image/refactoring/ParameterizeFunction.png)

### 使代码更易懂

我需要先理解代码在做什么，然后才能着手修改。这段代码可能是我写的，也可能是别人写的。一旦我需要思考“这段代码到底在做什么”​，我就会自问：能不能重构这段代码，令其一目了然？我可能看见了一段结构糟糕的条件逻辑，也可能希望复用一个函数，但花费了几分钟才弄懂它到底在做什么，因为它的函数命名实在是太糟糕了。这些都是重构的机会。


### 捡垃圾式重构

帮助理解的重构还有一个变体：我已经理解代码在做什么，但发现它做得不好，例如逻辑不必要地迂回复杂，或者两个函数几乎完全相同，可以用一个参数化的函数取而代之。这里有一个取舍：我不想从眼下正要完成的任务上跑题太多，但我也不想把垃圾留在原地，给将来的修改增加麻烦。如果我发现的垃圾很容易重构，我会马上重构它；如果重构需要花一些精力，我可能会拿一张便笺纸把它记下来，完成当下的任务再回来重构它。



重构不是与编程割裂的行为。你不会专门安排时间重构，正如你不会专门安排时间写if语句。我的项目计划上没有专门留给重构的时间，绝大多数重构都在我做其他事的过程中自然发生。在写代码时，我会做出很多权衡取舍：<sapn class="marker-text">参数化需要做到什么程度？函数之间的边界应该划在哪里？对于昨天的功能完全合理的权衡，在今天要添加新功能时可能就不再合理。好在，当我需要改变这些权衡以反映现实情况的变化时，整洁的代码重构起来会更容易。</sapn>



### 复审代码时重构

一些公司会做常规的代码复审（code review）​，因为这种活动可以改善开发状况。代码复审有助于在开发团队中传播知识，也有助于让较有经验的开发者把知识传递给比较欠缺经验的人，并帮助更多人理解大型软件系统中的更多部分。代码复审对于编写清晰代码也很重要。我的代码也许对我自己来说很清晰，对他人则不然。这是无法避免的，因为要让开发者设身处地为那些不熟悉自己所作所为的人着想，实在太困难了。代码复审也让更多人有机会提出有用的建议，毕竟我在一个星期之内能够想出的好点子很有限。如果能得到别人的帮助，我的生活会滋润得多，所以我总是期待更多复审。

### 何时不应该重构

听起来好像我一直在提倡重构，但确实有一些不值得重构的情况。如果我看见一块凌乱的代码，但并不需要修改它，那么我就不需要重构它。如果丑陋的代码能被隐藏在一个API之下，我就可以容忍它继续保持丑陋。<sapn class="marker-text">只有当我需要理解其工作原理时，对其进行重构才有价值。</sapn>另一种情况是，如果重写比重构还容易，就别重构了。这是个困难的决定。如果不花一点儿时间尝试，往往很难真实了解重构一块代码的难度。决定到底应该重构还是重写，需要良好的判断力与丰富的经验，我无法给出一条简单的建议。

<sapn class="marker-text">也就是说，如果一块代码我很少触碰，它不会经常给我带来麻烦，那么我就倾向于不去重构它</sapn>













