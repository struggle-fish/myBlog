::: tip
每当我要进行重构的时候，第一个步骤永远相同：我得确保即将修改的代码拥有一组可靠的测试
:::


`statement` 函数返回的是一个字符串，




```js
function statement (invoice, plays) {
  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `Statement for ${invoice.customer}\n`;
  const format = new Intl.NumberFormat("en-US",
                        { style: "currency", currency: "USD",
                          minimumFractionDigits: 2 }).format;

  for (let perf of invoice.performances) { 
    const play = plays[perf.playID];
    let thisAmount = 0;

    switch (play.type) {
    case "tragedy":
      thisAmount = 40000;
      if (perf.audience > 30) {
        thisAmount += 1000 * (perf.audience - 30);
      }
      break;
    case "comedy":
      thisAmount = 30000;
      if (perf.audience > 20) {
        thisAmount += 10000 + 500 * (perf.audience - 20);
      }
      thisAmount += 300 * perf.audience;
      break;
    default:
        throw new Error(`unknown type: ${play.type}`);
    }

    // add volume credits
    volumeCredits += Math.max(perf.audience - 30, 0);
    // add extra credit for every ten comedy attendees
    if ("comedy" === play.type) {
      volumeCredits += Math.floor(perf.audience / 5);
    }

    // print line for this order
    result += `
			${play.name}: ${format(thisAmount/100)} 
			(${perf.audience} seats)\n
		`;
    totalAmount += thisAmount;
  }
  result += `Amount owed is ${format(totalAmount/100)}\n`;
  result += `You earned ${volumeCredits} credits\n`;
  return result;
}

```

> 提炼函数（106）重构swith语句


首先先检查一下，如果将这块代码提炼到自己的一个函数里，有哪些变量会离开原本的作用域。 `perf`, `play`, `thisAmount` 这个3个变量。其中前两个变量会被提炼后的函数使用，但不会被修改，那么我就可以将它们以参数方式传递进来。这里只有唯一一个——`thisAmount`，因此可以将它从函数中直接返回。我还可以将其初始化放到提炼后的函数里

```js
function amountFor(perf, play) { // [!code focus] // [!code error]
  let thisAmount = 0;  // [!code focus] // [!code error]
  switch (play.type) {
  case "tragedy":
    thisAmount = 40000;
    if (perf.audience > 30) {
      thisAmount += 1000 * (perf.audience - 30);
    }
    break;
  case "comedy":
    thisAmount = 30000;
    if (perf.audience > 20) {
      thisAmount += 10000 + 500 * (perf.audience - 20);
    }
    thisAmount += 300 * perf.audience;
    break;
  default:
      throw new Error(`unknown type: ${play.type}`);
  }
  return thisAmount;
}
```

修改后的函数如下：

```js
function statement (invoice, plays) {
  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `Statement for ${invoice.customer}\n`;
  const format = new Intl.NumberFormat("en-US",
                        { style: "currency", currency: "USD",
                          minimumFractionDigits: 2 }).format;
  for (let perf of invoice.performances) {
    const play = plays[perf.playID];
    let thisAmount = amountFor(perf, play); // [!code focus] // [!code error]

    // add volume credits
    volumeCredits += Math.max(perf.audience - 30, 0);
    // add extra credit for every ten comedy attendees
    if ("comedy" === play.type) {
      volumeCredits += Math.floor(perf.audience / 5);
    }

    // print line for this order
    result += `
			 ${play.name}: ${format(thisAmount/100)} 
			 (${perf.audience} seats)\n
		`;
    totalAmount += thisAmount;
  }
  result += `Amount owed is ${format(totalAmount/100)}\n`;
  result += `You earned ${volumeCredits} credits\n`;
  return result;
```

做完一次小的改动后就立马测试，如果自测没问题后，看看提炼出来的函数，看是否能进一步提升其表达能力。一般做的第一件事就是给一些变量改名，使它们更简洁，比如将`thisAmount重命名为result`。

```js
function amountFor(perf, play) { 
  let thisAmount = 0;  // [!code --]
	let result = 0;  // [!code ++]
  switch (play.type) {
  case "tragedy":
    thisAmount = 40000; // [!code --]
		result = 40000; // [!code ++]
    if (perf.audience > 30) {
      thisAmount += 1000 * (perf.audience - 30); // [!code --]
			result += 1000 * (perf.audience - 30); // [!code ++]
    }
    break;
  case "comedy":
    thisAmount = 30000; // [!code --]
		result = 30000; // [!code ++]
    if (perf.audience > 20) {
      thisAmount += 10000 + 500 * (perf.audience - 20); // [!code --]
			result += 10000 + 500 * (perf.audience - 20); // [!code ++]
    }
    thisAmount += 300 * perf.audience; // [!code --]
		result += 300 * perf.audience; // [!code ++]
    break;
  default:
      throw new Error(`unknown type: ${play.type}`);
  }
  return thisAmount; // [!code --]
	return result; // [!code ++]
}
```



