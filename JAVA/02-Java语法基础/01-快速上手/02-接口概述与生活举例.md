# 接口详解



## 接口概述

接口就是一种 `公共的规规范标准`, 只要符合规范标准,就可以大家通用.

各个厂商都是自己生产自己的,但是生产出来却能通用
比如生活中使用的电源插座,遵循国标. 比如USB接口,只要符合USB接口的规范
那么各种设备都可以使用,U盘,充电宝,电脑,USB小风扇.

## 接口的基本格式

在代码中,接口就是多个类的公共规范,是一种引用数据类型.
最重要的内容就是`抽象方法`

``` java
/*
java 7 接口可以包含的内容:
    1. 常量
    2. 抽象方法
java 8 接口还额外包含:
    3. 默认方法
    4. 静态方法
java 9 接口还额外包含:
    5. 私有方法
*/

public interface 接口名称 {
    // 接口中的抽象方法
    返回值类型 方法名(参数列表);
}

```

## 接口的抽象方法

在任何版本的java中,接口都可以定义抽象方法

::: code-group
```java [格式]

public interface 接口名称 {
    // 抽象方法
    返回值类型 方法名(参数列表);
}
```

```java [示例]
注意事项:
1. 接口中的方法默认都是`public abstract`的,所以可以省略不写
public interface MyInterfaceAbstract  {
    // 抽象方法
    void eat();
    void sleep();
    public abstract void methodAbs();
    abstract void methodAbs2();
    public void methodAbs3();
    void methodAbs4();
    // 接口中的方法不能有方法体
} 
```

```java [抽象方法使用]
1.接口不能直接使用,必须有一个"实现类"来"实现"该接口
2.实现类必须重写(实现)接口中的所有抽象方法,即 去掉 abstract 关键字,加上方法体大括号
3.创建实现类的对象,进行使用

注意:
1. 实现类必须使用 implements 关键字来实现接口
2. 如果实现类没有重写接口中的所有抽象方法,那么这个实现类自己就必须是抽象类

格式:
public class 类名 implements 接口名 {
    // 重写接口中的抽象方法
}

public class MyInterfaceAbstractImpl implements MyInterfaceAbstract {
    @Override
    public void eat() {
        System.out.println("吃");
    }
    @Override
    public void sleep() {
        System.out.println("睡");
    }
    @Override
    public void methodAbs() {
        System.out.println("抽象方法1");
    }
    @Override
    public void methodAbs2() {
        System.out.println("抽象方法2");
    }
    @Override
    public void methodAbs3() {
        System.out.println("抽象方法3");
    }
    @Override   
    public void methodAbs4() {
        System.out.println("抽象方法4");
    }
}

```
``` java[使用实现类]

public class InterfaceAbstractDemo {
    public static void main(String[] args) {
        // 创建实现类的对象
        // 注意: 接口不能直接使用,必须有一个"实现类"来"实现"该接口
        MyInterfaceAbstractImpl impl = new MyInterfaceAbstractImpl();
        impl.eat();
        impl.sleep();
        impl.methodAbs();
        impl.methodAbs2();
        impl.methodAbs3();
        impl.methodAbs4();
    }
}

```
::: 


## 接口的默认方法

从java8 开始,接口可以定义默认方法,即可以有方法体.

::: code-group
```java [格式]

public interface 接口名称 {
    // 抽象方法
    返回值类型 方法名(参数列表);
    // 默认方法
    default 返回值类型 方法名(参数列表) {
        // 方法体
    }
}
接口当中的默认方法,可以直接使用,也可以被重写,可以解决接口升级的问题
```

```java [示例]

public interface MyInterfaceDefault {
    // 抽象方法
    public abstract void methodAbs();
}

public class MyInterfaceDefaultA implements MyInterfaceDefault {
    @Override
    public void methodAbs() {
        System.out.println("实现类A重写了抽象方法");
    }
}


public class MyInterfaceDefaultB implements MyInterfaceDefault {
    @Override
    public void methodAbs() {
        System.out.println("实现类B重写了抽象方法");
    }
}

如果此时 MyInterfaceDefault 再追加一个抽象方法,
那么 MyInterfaceDefaultA 和 MyInterfaceDefaultA 就需要重写这个方法,
但是 MyInterfaceDefaultA 和 MyInterfaceDefaultB 都已经在使用中了,
在改一次风险很大, 那如何解决这个问题呢? 即
MyInterfaceDefaultA 和 MyInterfaceDefaultB 不需要改动,
但是 MyInterfaceDefault 还能在扩展一个方法



```

```java [解决]
public interface MyInterfaceDefault {
    // 抽象方法
    public abstract void methodAbs();
    // 默认方法
    public default void methodDefault() {
        System.out.println("这是一个默认方法");
    }
}

```

```java [使用默认方法]

public class InterfaceDefaultDemo {
    public static void main(String[] args) {
        // 创建实现类的对象
        MyInterfaceDefaultA implA = new MyInterfaceDefaultA();
        implA.methodAbs(); // 调用抽象方法
        implA.methodDefault(); // 调用默认方法 直接用

        MyInterfaceDefaultB implB = new MyInterfaceDefaultB();
        implB.methodAbs(); // 调用抽象方法
        // 如果实现类里没有,那会向上找
        implB.methodDefault(); // 调用默认方法 直接用
    }
}

```
:::


## 接口的静态方法

java 8 开始,接口可以定义静态方法,即可以有方法体.

::: code-group
```java [格式]
public interface 接口名称 {
    // 抽象方法
    返回值类型 方法名(参数列表);
    
     // 静态方法
    public static 返回值类型 方法名(参数列表) {
        // 方法体
    }
}
```

```java [示例]

public interface MyInterfaceStatic {
    // 抽象方法
    public abstract void methodAbs();
    // 静态方法
    public static void methodStatic() {
        System.out.println("这是一个静态方法");
    }
}

```

```java [使用静态方法]
public class InterfaceStaticDemo {
    public static void main(String[] args) {
        // 接口名.静态方法名(参数列表);
        MyInterfaceStatic.methodStatic();
    }
}   
```

:::

## 接口的私有方法

java 9 及以上版本,接口可以定义私有方法,即可以有方法体.
用于抽取公共方法,给默认方法和静态方法使用.
这个公共方法不能被外部直接调用.

- 普通私有方法,解决多个默认方法之间重复代码问题
- 静态私有方法,解决多个静态方法之间重复代码问题

::: code-group
```java [格式]
public interface 接口名称 {
    // 抽象方法
    返回值类型 方法名(参数列表);
    // 默认方法
    default 返回值类型 方法名(参数列表) {
        // 方法体
    }
    // 静态方法
    public static 返回值类型 方法名(参数列表) {
        // 方法体
    }
    // 私有方法
    private 返回值类型 方法名(参数列表) {
        // 方法体
    }
}

```

```java [示例]
public interface MyInterfacePrivate {
    // 抽象方法
    public abstract void methodAbs();
    // 默认方法
    public default void methodDefault() {
        System.out.println("这是一个默认方法");
        methodPrivate();
    }
    // 静态方法
    public static void methodStatic() {
        System.out.println("这是一个静态方法");
        methodStaticPrivate();
    }
    // 私有方法
    private void methodPrivate() {
        System.out.println("这是一个私有方法");
    }
    private static void methodStaticPrivate() {
        System.out.println("这是一个静态私有方法");
    }
}
```


:::


## 接口的常量

接口中可以定义常量,常量的修饰符默认是 `public static final` 的,
即可以省略不写. 一旦使用 `final` 修饰,就不能修改了.

::: code-group
```java [格式]
public interface 接口名称 {
    // 常量
    public static final 数据类型 常量名 = 数据值;
    
}
```

```java [示例]
public interface MyInterfaceConst {
    // 常量
    public static final int NUM = 10;
    int NUM2 = 20;
}

```
```java [使用常量]
public class InterfaceConstDemo {
    public static void main(String[] args) {
        // 接口名.常量名;
        System.out.println(MyInterfaceConst.NUM);
        System.out.println(MyInterfaceConst.NUM2);
    }
}   
```
:::


在 `java 9+ ` 接口的内容可有

- 成员变量(常量)
  - `[public] [static] [final] 数据类型 常量名 = 数据值`;
  - 常量必须进行赋值且不能改变
  - 常量名使用完全大写,用下划线分隔
- 抽象方法
    - `[public] [abstract] 返回值类型 方法名(参数列表);`
    - 实现类必须覆盖重写接口所有的抽象方法,除非实现类是抽象类
- 私有方法
    - `private 返回值类型 方法名(参数列表) { 方法体 }`
    - `private static 返回值类型 方法名(参数列表) { 方法体 }`
    - 只能在接口中使用,不能被实现类或其他接口使用
    - 私有方法的作用,解决多个默认方法或静态方法之间的重复代码问题


从 `java 8 `开始,接口还可以有

- 默认方法
  - `[public] default 返回值类型 方法名(参数列表) { 方法体 }`
  - 实现类可以直接使用,也可以覆盖重写
- 静态方法
  - `[public] static 返回值类型 方法名(参数列表) { 方法体 }`
  - 接口名.方法名(参数列表);直接调用


## 接口的继承

- 类与类之间是单继承的,即一个类只能有一个直接父类
- 类与接口之间是实现关系,即一个类可以实现多个接口
- 接口与接口之间是多继承关系,即一个接口可以继承多个接口

注意:

- 多个父接口当中的抽象方法如果重复,没关系
- 多个父接口当中的默认方法如果重复,那么子接口必须进行默认方法的覆盖重写,而且带着 `default` 关键字


::: code-group
```java [格式]
public interface 接口名称 extends 父接口1, 父接口2, ... {
    // 接口中的抽象方法
    返回值类型 方法名(参数列表);
}
```

```java [示例]
public interface MyInterfaceA {
    public abstract void methodA();
    public abstract void methodCommon();
    public default void methodDefault() {
        System.out.println("这是接口A的默认方法");
    }
}
public interface MyInterfaceB {
    public abstract void methodB();
    public abstract void methodCommon();
    public default void methodDefault() {
        System.out.println("这是接口B的默认方法");
    }
}
public interface MyInterfaceC extends MyInterfaceA, MyInterfaceB {
    public abstract void methodC();
    // 如果接口C没有重写 methodDefault(),那么就会报错
    @Override
    public default void methodDefault() {
        System.out.println("这是接口C的默认方法");
    }
}
```

```java [使用]
public class InterfaceExtendsDemo implements MyInterfaceC {
    @Override
    public void methodA() {
        System.out.println("实现了接口A的方法");
    }
    @Override
    public void methodB() {
        System.out.println("实现了接口B的方法");
    }
    @Override
    public void methodC() {
        System.out.println("实现了接口C的方法");
    }
    
    @Override
    public void methodCommon() {
        System.out.println("实现了接口A和接口B的重复方法");
    }
    @Override
    public void methodDefault() {
        System.out.println("实现了接口A和接口B的重复方法");
    }
    
    public static void main(String[] args) {
        InterfaceExtendsDemo demo = new  ();
        demo.methodA();
        demo.methodB();
        demo.methodC();
    }
}
``` 


:::



## 注意事项

- 接口是没有静态代码块和构造方法的,因为接口不能直接使用,必须有实现类来实现接口.
- 一个类的直接父类是唯一的,但是一个类可以同时实现多个接口
- 如果实现类所实现的接口中有重复的抽象方法,那么只需要重写一次即可
- 如果实现类没有重写接口中的所有抽象方法,那么这个实现类自己就必须是抽象类
- 如果实现类所实现的接口中有重复的默认方法,那么实现类必须重写一次默认方法
- 一个类如果直接父类当中的方法和接口中的默认方法重复,那么直接父类的方法优先级更高 继承优先于接口实现












































