# 一个案例


需求：基于SpringBoot开发web程序，完成用户列表的渲染展示


![LOGO](/public/image/javapublic/e6871646-1436-4ff5-adf7-0840eea9e72d.png)


当在浏览器地址栏，访问前端静态页面`http://localhost:8080/usre.html`
后，在前端页面上，会发送ajax请求，请求服务端
`http://localhost:8080/list ` 服务端程序加载 `user.txt` 文件中的数据，
读取出来后最终给前端页面响应json格式的数据，前端页面再将数据渲染展示在表格中。


### 创建工程

- 准备工作：再创建一个SpringBoot工程，并勾选web依赖、`lombok依赖`。
  
![LOGO](/public/image/javapublic/359dc007-c18a-4bb9-8736-19d9835010f0.png)


![LOGO](/public/image/javapublic/d58a1807-f7bc-4ac6-87e1-7f1771397f4e.png)


### 准备数据

- 准备工作：将数据文件`user.txt`，以及static下的前端静态页面


![LOGO](/public/image/javapublic/37457cf7-c411-4270-9159-081ebbeb6bb3.png)

### 用户信息实体类

- 准备工作：定义封装用户信息的实体类。

::: code-group

```java [User实体类]
package com.itheima.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.time.LocalDateTime;

/**
 * 封装用户信息
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {
    private Integer id;
    private String username;
    private String password;
    private String name;
    private Integer age;
    private LocalDateTime updateTime;
}
```

:::

### 数据响应

- 开发服务端程序，接收请求，读取文本数据并响应

需要读取文本中的数据，并且还需要将对象转为json格式，所以，
在项目中再引入一个非常常用的工具包 `hutool`。 然后调用里面的工具类，
就可以非常方便快捷的完成业务操作。

::: code-group

```xml [引入依赖]
<!--pom.xml中引入依赖-->
<dependency>
    <groupId>cn.hutool</groupId>
    <artifactId>hutool-all</artifactId>
    <version>5.8.27</version>
</dependency>
```

```java [UserController]

import cn.hutool.core.io.IoUtil;
import cn.hutool.json.JSONConfig;
import cn.hutool.json.JSONUtil;
import com.itheima.pojo.User;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@RestController
public class UserController {
    
    @RequestMapping("/list")
    public String list(){
        //1.加载并读取文件
        InputStream in = this.getClass()
                          .getClassLoader()
                          .getResourceAsStream("user.txt");
        ArrayList<String> lines = IoUtil.readLines(
                            in,
                            StandardCharsets.UTF_8,
                            new ArrayList<>()
                        );
        
        //2.解析数据，封装成对象 --> 集合
        List<User> userList = lines.stream().map(line -> {
            String[] parts = line.split(",");
            Integer id = Integer.parseInt(parts[0]);
            String username = parts[1];
            String password = parts[2];
            String name = parts[3];
            Integer age = Integer.parseInt(parts[4]);
            LocalDateTime updateTime = LocalDateTime.parse(
                parts[5],
                DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")
            );

            return new User(id, username, password, name, age, updateTime);
        }).collect(Collectors.toList());
        
        //3.响应数据
        return userList;
    }
    
}

```

:::
    


### ResponseBody


直接`return userList;` 页面就能接受到 `json` 格式的数据了, 这是为啥呢?

使用@ResponseBody注解


**@ResponseBody注解：**
- 类型：方法注解、类注解
- 位置：书写在Controller方法上或类上
- 作用：将方法返回值直接响应给浏览器，如果返回值类型是实体对象/集合，将会转换为JSON格式后在响应给浏览器



类上加了`@RestController = @Controller + @ResponseBody`注解，而这个注解是由两个注解组合起来的，分别是：
`@Controller` 、`@ResponseBody`。 
那也就意味着，我们在类上已经添加了`@ResponseBody`注解了，
而一旦在类上加了`@ResponseBody`注解，
就相当于该类所有的方法中都已经添加了`@ResponseBody`注解。 







