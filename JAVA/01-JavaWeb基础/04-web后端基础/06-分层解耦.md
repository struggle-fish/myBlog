# 分层解耦

### 问题分析

现在在程序中，需要什么对象，直接new一个对象 比如 `new UserServiceImpl()`

![LOGO](/public/image/javapublic/61aba1f6-e0d5-470d-9b92-bd5c3c6883aa.png)



如果说我们需要更换实现类，比如由于业务的变更，
UserServiceImpl 不能满足现有的业务需求，
我们需要切换为 UserServiceImpl2 这套实现，
就需要修改Contorller的代码，
需要创建 UserServiceImpl2 的实现 `new UserServiceImpl2()` 。

![LOGO](/public/image/javapublic/101e3891-7b41-4058-99d6-a331ae20c179.png)

Service中调用Dao，也是类似的问题。这种呢，我们就称之为层与层之间 `耦合` 了。
那什么是耦合呢 ？

::: tip 内聚和耦合
首先需要了解软件开发涉及到的两个概念：内聚和耦合。
- 内聚：软件中各个功能模块内部的功能联系。
- 耦合：衡量软件中各个层/模块之间的依赖、关联的程度。
:::


::: danger 高内聚低耦合
软件设计原则：高内聚低耦合。
高内聚：指的是一个模块中各个元素之间的联系的紧密程度，如果各个元素(语句、程序段)之间的联系程度越高，则内聚性越高，即 "高内聚"。
低耦合：指的是软件中各个层、模块之间的依赖关联程序越低越好。
:::

目前层与层之间是存在耦合的，Controller耦合了Service、Service耦合了Dao。
`而 高内聚、低耦合的目的是使程序模块的可重用性、移植性大大增强`。
那最终我们的目标呢，就是做到层与层之间，尽可能的降低耦合，甚至解除耦合。

![LOGO](/public/image/javapublic/51db9f28-c9d7-4e65-a8fb-8eb291936349.png)


### 解耦思路

![LOGO](/public/image/javapublic/WX20250501-143937@2x.png)

之前我们在编写代码时，需要什么对象，就直接new一个就可以了。 这种做法呢，层与层之间代码就耦合了，
当service层的实现变了之后， 我们还需要修改controller层的代码。

- 首先不能在EmpController中使用new对象。代码如下：


![LOGO](/public/image/javapublic/1ea24df5-d0d9-4d0f-9fdf-a2ddaa0aadd4.png)

此时，就存在另一个问题了，不能new，就意味着没有业务层对象（程序运行就报错），怎么办呢?
我们的解决思路是：
- 提供一个容器，容器中存储一些对象(例：UserService对象)
- Controller程序从容器中获取UserService类型的对象



- 将要用到的对象交给一个容器管理。

![LOGO](/public/image/javapublic/e47c6b5b-a509-485d-929d-ea70992af0d8.png)


- 应用程序中用到这个对象，就直接从容器中获取

![LOGO](/public/image/javapublic/f909918b-b322-40e4-816d-40477dbda80f.png)

那问题来了，我们如何将对象交给容器管理呢？ 程序运行时，容器如何为程序提供依赖的对象呢？

我们想要实现上述解耦操作，就涉及到Spring中的两个核心概念：

::: danger 两个核心概念
- 控制反转： Inversion Of Control，简称IOC。对象的创建控制权由程序自身转移到外部（容器），这种思想称为控制反转。
    - 对象的创建权由程序员主动创建转移到容器(由容器创建、管理对象)。这个容器称为：IOC容器或Spring容器。

- 依赖注入： Dependency Injection，简称DI。容器为应用程序提供运行时，所依赖的资源，称之为依赖注入。
    - 程序运行时需要某个资源，此时容器就为其提供这个资源。
    - 例：EmpController程序运行时需要EmpService对象，Spring容器就为其提供并注入EmpService对象。

- bean对象：IOC容器中创建、管理的对象，称之为：bean对象。

:::


## IOC & DI 

- 将Service及Dao层的实现类，交给IOC容器管理

在实现类加上 `@Component` 注解，就代表把当前类产生的对象交给IOC容器管理。

::: code-group

```java [UserDaoImpl]


@Component // [!code ++]
public class UserDaoImpl implements UserDao {
    @Override
    public List<String> findAll() {
        InputStream in = this.getClass()
                        .getClassLoader()
                        .getResourceAsStream("user.txt");
        ArrayList<String> lines = IoUtil.readLines(
                        in, 
                        StandardCharsets.UTF_8, 
                        new ArrayList<>()
                      );
        return lines;
    }
}

```

```java [UserServiceImpl]
@Component // [!code ++]
public class UserServiceImpl implements UserService {

    private UserDao userDao;

    @Override
    public List<User> findAll() {
        List<String> lines = userDao.findAll();
        List<User> userList = lines.stream().map(line -> {
            String[] parts = line.split(",");
            Integer id = Integer.parseInt(parts[0]);
            String username = parts[1];
            String password = parts[2];
            String name = parts[3];
            Integer age = Integer.parseInt(parts[4]);
            LocalDateTime updateTime = LocalDateTime.parse(
                parts[5],
                DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")
              );
            return new User(
                      id, 
                      username, 
                      password, 
                      name, 
                      age, 
                      updateTime
                     );
        }).collect(Collectors.toList());
        return userList;
    }
}


```

:::


- 为Controller 及 Service注入运行时所依赖的对象

::: code-group
```java [UserServiceImpl]
@Component
public class UserServiceImpl implements UserService {

    @Autowired // [!code ++]
    private UserDao userDao;
    
    @Override
    public List<User> findAll() {
        List<String> lines = userDao.findAll();
        List<User> userList = lines.stream().map(line -> {
            String[] parts = line.split(",");
            Integer id = Integer.parseInt(parts[0]);
            String username = parts[1];
            String password = parts[2];
            String name = parts[3];
            Integer age = Integer.parseInt(parts[4]);
            LocalDateTime updateTime = LocalDateTime.parse(
                            parts[5],
                            DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")
                           );
            return new User(
                    id,
                    username, 
                    password, 
                    name, 
                    age, 
                    updateTime
                   );
        }).collect(Collectors.toList());
        return userList;
    }
}

```

:::


![LOGO](/public/image/javapublic/WX20250501-220314@2x.png)
![LOGO](/public/image/javapublic/WX20250501-220942@2x.png)




## IOC 详解

IOC控制反转，就是将对象的控制权交给Spring的IOC容器，
由IOC容器创建及管理对象。IOC容器创建的对象称为bean对象。
要把某个对象交给IOC容器管理，需要在类上添加一个注解：`@Component`

而Spring框架为了更好的标识web应用程序开发当中，
bean对象到底归属于哪一层，又提供了`@Component`的衍生注解：

![LOGO](/public/image/javapublic/WX20250519-094937@2x.png)


用 `@Service` 注解声明Service层的bean。 使用 `@Repository` 注解声明Dao层的bean。 
代码实现如下：

::: code-group
```java [UserServiceImpl]
@Service // [!code ++]
public class UserServiceImpl implements UserService {
    private UserDao userDao;

    @Override
    public List<User> findAll() {
        List<String> lines = userDao.findAll();
        List<User> userList = lines.stream().map(line -> {
            String[] parts = line.split(",");
            Integer id = Integer.parseInt(parts[0]);
            String username = parts[1];
            String password = parts[2];
            String name = parts[3];
            Integer age = Integer.parseInt(parts[4]);
            LocalDateTime updateTime = LocalDateTime.parse(
                  parts[5],
                  DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")
                );
            return new User(
                id, 
                username, 
                password, 
                name, 
                age, 
                updateTime
              );
        }).collect(Collectors.toList());
        return userList;
    }
}
```

``` java [UserDaoImpl]

@Repository // [!code ++]
public class UserDaoImpl implements UserDao {
    @Override
    public List<String> findAll() {
        InputStream in = this.getClass()
                          .getClassLoader()
                          .getResourceAsStream("user.txt");
        ArrayList<String> lines = IoUtil.readLines(
                            in,
                            StandardCharsets.UTF_8,
                            new ArrayList<>()
                         );
        return lines;
    }
}


```
:::


::: tip 注意

问题：使用前面学习的四个注解声明的bean，一定会生效吗？

答案：不一定。（原因：bean想要生效，还需要被组件扫描）

:::

- 前面声明bean的四大注解，要想生效，还需要被组件扫描注解 `@ComponentScan` 扫描。
- 该注解虽然没有显式配置，但是实际上已经包含在了启动类声明注解 `@SpringBootApplication` 中，默认扫描的范围是启动类所在包及其子包。

![LOGO](/public/image/javapublic/f6842221-a758-461c-8d02-585aa9150ad1.png)

在项目开发中，只需要按照如上项目结构，将项目中的所有的业务类，都放在启动类所在包的子包中，就无需考虑组件扫描问题。

## DI 详解

依赖注入指的是应用程序在运行的时候,所依赖的资源需要容器为其提供,
这个过程称之为依赖注入

依赖注入，是指`IOC`容器要为应用程序去提供运行时所依赖的资源，而资源指的就是对象。
入门程序案例中，我们使用了`@Autowired`这个注解，完成了依赖注入的操作，而这个Autowired翻译过来叫：`自动装配`。

![LOGO](/public/image/javapublic/WX20250609-103354@2x.png)

::: tip
`@Autowired`注解，默认是按照类型进行自动装配的（去IOC容器中找某个类型的对象，然后完成注入操作）
入门程序举例：在`EmpController`运行的时候，
就要到IOC容器当中去查找`EmpService`这个类型的对象，
而我们的IOC容器中刚好有一个`EmpService`这个类型的对象，
所以就找到了这个类型的对象完成注入操作。
:::

::: code-group

```java[属性注入]
- 优点：代码简洁、方便快速开发。
- 缺点：隐藏了类之间的依赖关系、可能会破坏类的封装性。
@RestController
public class UserController {

  //方式一: 属性注入
  @Autowired
  private UserService userService;
  
}
```

```java[构造器注入]
- 优点：能清晰地看到类的依赖关系、提高了代码的安全性。
- 缺点：代码繁琐、如果构造参数过多，可能会导致构造函数臃肿。
@RestController
public class UserController {
  //方式二: 构造器注入
  private final UserService userService;
  
  @Autowired
  public UserController(UserService userService) {
    this.userService = userService;
  }
} 
```
```java[setter方法注入]
- 优点：保持了类的封装性，依赖关系更清晰。
- 缺点：需要额外编写setter方法，增加了代码量。

@RestController
public class UserController {
  //方式三: setter方法注入
  private UserService userService;
  
  @Autowired
  public void setUserService(UserService userService) {
    this.userService = userService;
  }
} 
```

:::





## Autowired 注解

`@Autowired `注解默认是按照`类型`进行的,那如果再IOC容器中存在多个相同类型的bean对象，会出现什么情况呢？

在下面的例子中，我们准备了两个UserService的实现类，并且都交给了IOC容器管理。 代码如下：

![LOGO](/public/image/javapublic/07aba447-eda3-4fe6-a4b3-54ba78c6783d.png)

此时，我们启动项目会发现，控制台报错了：



![LOGO](/public/image/javapublic/90c19dba-202b-42e2-8488-baa04120a60e.png)

出现错误的原因呢，是因为在Spring的容器中，UserService这个类型的bean存在两个，框架不知道具体要注入哪个bean使用，所以就报错了。

如何解决上述问题呢？Spring提供了以下几种解决方案：
- @Primary
- @Qualifier
- @Resource


::: code-group

```java [Primary]
@Primary
@Service
public class UserServiceImpl implements UserService {
}
```

```java[Qualifier]
指定当前要注入的bean对象。 
在@Qualifier的value属性中，指定注入的bean的名称。 
@Qualifier注解不能单独使用，必须配合@Autowired使用。

@RestController
public class UserController {

    @Qualifier("userServiceImpl")
    @Autowired
    private UserService userService;
}
```

```java[Resource]

是按照bean的名称进行注入。通过name属性指定要注入的bean的名称。

@RestController
public class UserController {
        
    @Resource(name = "userServiceImpl")
    private UserService userService;
}
```

:::


::: tip  `@Autowird` 与` @Resource`的区别
- `@Autowired `是spring框架提供的注解，而`@Resource`是JDK提供的注解
- `@Autowired` 默认是按照类型注入，而`@Resource`是按照名称注入

:::

![LOGO](/public/image/javapublic/WX20250609-112957@2x.png)























































































