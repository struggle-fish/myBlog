# 分层解耦

### 问题分析

现在在程序中，需要什么对象，直接new一个对象 比如 `new UserServiceImpl()`

![LOGO](/public/image/javapublic/61aba1f6-e0d5-470d-9b92-bd5c3c6883aa.png)



如果说我们需要更换实现类，比如由于业务的变更，
UserServiceImpl 不能满足现有的业务需求，
我们需要切换为 UserServiceImpl2 这套实现，
就需要修改Contorller的代码，
需要创建 UserServiceImpl2 的实现 `new UserServiceImpl2()` 。

![LOGO](/public/image/javapublic/101e3891-7b41-4058-99d6-a331ae20c179.png)

Service中调用Dao，也是类似的问题。这种呢，我们就称之为层与层之间 `耦合` 了。
那什么是耦合呢 ？

::: tip 内聚和耦合
首先需要了解软件开发涉及到的两个概念：内聚和耦合。
- 内聚：软件中各个功能模块内部的功能联系。
- 耦合：衡量软件中各个层/模块之间的依赖、关联的程度。
:::


::: danger 高内聚低耦合
软件设计原则：高内聚低耦合。
高内聚：指的是一个模块中各个元素之间的联系的紧密程度，如果各个元素(语句、程序段)之间的联系程度越高，则内聚性越高，即 "高内聚"。
低耦合：指的是软件中各个层、模块之间的依赖关联程序越低越好。
:::

目前层与层之间是存在耦合的，Controller耦合了Service、Service耦合了Dao。
`而 高内聚、低耦合的目的是使程序模块的可重用性、移植性大大增强`。
那最终我们的目标呢，就是做到层与层之间，尽可能的降低耦合，甚至解除耦合。

![LOGO](/public/image/javapublic/51db9f28-c9d7-4e65-a8fb-8eb291936349.png)


### 解耦思路

![LOGO](/public/image/javapublic/WX20250501-143937@2x.png)

之前我们在编写代码时，需要什么对象，就直接new一个就可以了。 这种做法呢，层与层之间代码就耦合了，
当service层的实现变了之后， 我们还需要修改controller层的代码。

- 首先不能在EmpController中使用new对象。代码如下：


![LOGO](/public/image/javapublic/1ea24df5-d0d9-4d0f-9fdf-a2ddaa0aadd4.png)

此时，就存在另一个问题了，不能new，就意味着没有业务层对象（程序运行就报错），怎么办呢?
我们的解决思路是：
- 提供一个容器，容器中存储一些对象(例：UserService对象)
- Controller程序从容器中获取UserService类型的对象



- 将要用到的对象交给一个容器管理。

![LOGO](/public/image/javapublic/e47c6b5b-a509-485d-929d-ea70992af0d8.png)


- 应用程序中用到这个对象，就直接从容器中获取

![LOGO](/public/image/javapublic/f909918b-b322-40e4-816d-40477dbda80f.png)

那问题来了，我们如何将对象交给容器管理呢？ 程序运行时，容器如何为程序提供依赖的对象呢？

我们想要实现上述解耦操作，就涉及到Spring中的两个核心概念：

::: danger 两个核心概念
- 控制反转： Inversion Of Control，简称IOC。对象的创建控制权由程序自身转移到外部（容器），这种思想称为控制反转。
    - 对象的创建权由程序员主动创建转移到容器(由容器创建、管理对象)。这个容器称为：IOC容器或Spring容器。

- 依赖注入： Dependency Injection，简称DI。容器为应用程序提供运行时，所依赖的资源，称之为依赖注入。
    - 程序运行时需要某个资源，此时容器就为其提供这个资源。
    - 例：EmpController程序运行时需要EmpService对象，Spring容器就为其提供并注入EmpService对象。

- bean对象：IOC容器中创建、管理的对象，称之为：bean对象。

:::


## IOC & DI 

- 将Service及Dao层的实现类，交给IOC容器管理

在实现类加上 `@Component` 注解，就代表把当前类产生的对象交给IOC容器管理。

::: code-group

```java [UserDaoImpl]


@Component // [!code ++]
public class UserDaoImpl implements UserDao {
    @Override
    public List<String> findAll() {
        InputStream in = this.getClass()
                        .getClassLoader()
                        .getResourceAsStream("user.txt");
        ArrayList<String> lines = IoUtil.readLines(
                        in, 
                        StandardCharsets.UTF_8, 
                        new ArrayList<>()
                      );
        return lines;
    }
}

```

```java [UserServiceImpl]
@Component // [!code ++]
public class UserServiceImpl implements UserService {

    private UserDao userDao;

    @Override
    public List<User> findAll() {
        List<String> lines = userDao.findAll();
        List<User> userList = lines.stream().map(line -> {
            String[] parts = line.split(",");
            Integer id = Integer.parseInt(parts[0]);
            String username = parts[1];
            String password = parts[2];
            String name = parts[3];
            Integer age = Integer.parseInt(parts[4]);
            LocalDateTime updateTime = LocalDateTime.parse(
                parts[5],
                DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")
              );
            return new User(
                      id, 
                      username, 
                      password, 
                      name, 
                      age, 
                      updateTime
                     );
        }).collect(Collectors.toList());
        return userList;
    }
}


```

:::


- 为Controller 及 Service注入运行时所依赖的对象

::: code-group
```java [UserServiceImpl]
@Component
public class UserServiceImpl implements UserService {

    @Autowired // [!code ++]
    private UserDao userDao;
    
    @Override
    public List<User> findAll() {
        List<String> lines = userDao.findAll();
        List<User> userList = lines.stream().map(line -> {
            String[] parts = line.split(",");
            Integer id = Integer.parseInt(parts[0]);
            String username = parts[1];
            String password = parts[2];
            String name = parts[3];
            Integer age = Integer.parseInt(parts[4]);
            LocalDateTime updateTime = LocalDateTime.parse(
                            parts[5],
                            DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")
                           );
            return new User(
                    id,
                    username, 
                    password, 
                    name, 
                    age, 
                    updateTime
                   );
        }).collect(Collectors.toList());
        return userList;
    }
}

```

:::


![LOGO](/public/image/javapublic/WX20250501-220314@2x.png)
![LOGO](/public/image/javapublic/WX20250501-220942@2x.png)




## IOC 详解

IOC控制反转，就是将对象的控制权交给Spring的IOC容器，
由IOC容器创建及管理对象。IOC容器创建的对象称为bean对象。
要把某个对象交给IOC容器管理，需要在类上添加一个注解：`@Component`

而Spring框架为了更好的标识web应用程序开发当中，
bean对象到底归属于哪一层，又提供了`@Component`的衍生注解：

![LOGO](/public/image/javapublic/WX20250519-094937@2x.png)


用 `@Service` 注解声明Service层的bean。 使用 `@Repository` 注解声明Dao层的bean。 
代码实现如下：

::: code-group
```java [UserServiceImpl]
@Service // [!code ++]
public class UserServiceImpl implements UserService {
    private UserDao userDao;

    @Override
    public List<User> findAll() {
        List<String> lines = userDao.findAll();
        List<User> userList = lines.stream().map(line -> {
            String[] parts = line.split(",");
            Integer id = Integer.parseInt(parts[0]);
            String username = parts[1];
            String password = parts[2];
            String name = parts[3];
            Integer age = Integer.parseInt(parts[4]);
            LocalDateTime updateTime = LocalDateTime.parse(
                  parts[5],
                  DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")
                );
            return new User(
                id, 
                username, 
                password, 
                name, 
                age, 
                updateTime
              );
        }).collect(Collectors.toList());
        return userList;
    }
}
```

``` java [UserDaoImpl]

@Repository // [!code ++]
public class UserDaoImpl implements UserDao {
    @Override
    public List<String> findAll() {
        InputStream in = this.getClass()
                          .getClassLoader()
                          .getResourceAsStream("user.txt");
        ArrayList<String> lines = IoUtil.readLines(
                            in,
                            StandardCharsets.UTF_8,
                            new ArrayList<>()
                         );
        return lines;
    }
}


```
:::


::: tip 注意

问题：使用前面学习的四个注解声明的bean，一定会生效吗？

答案：不一定。（原因：bean想要生效，还需要被组件扫描）

:::

- 前面声明bean的四大注解，要想生效，还需要被组件扫描注解 `@ComponentScan` 扫描。
- 该注解虽然没有显式配置，但是实际上已经包含在了启动类声明注解 `@SpringBootApplication` 中，默认扫描的范围是启动类所在包及其子包。

![LOGO](/public/image/javapublic/f6842221-a758-461c-8d02-585aa9150ad1.png)

在项目开发中，只需要按照如上项目结构，将项目中的所有的业务类，都放在启动类所在包的子包中，就无需考虑组件扫描问题。

## DI 详解






























































































